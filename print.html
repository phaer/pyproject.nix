<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pyproject.nix</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="HACKING.html"><strong aria-hidden="true">2.</strong> Hacking</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">3.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">4.</strong> User facing APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lib/project.html"><strong aria-hidden="true">4.1.</strong> project</a></li><li class="chapter-item expanded "><a href="lib/renderers.html"><strong aria-hidden="true">4.2.</strong> renderers</a></li><li class="chapter-item expanded "><a href="lib/validators.html"><strong aria-hidden="true">4.3.</strong> validators</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">5.</strong> Standards APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lib/pep427.html"><strong aria-hidden="true">5.1.</strong> pep427</a></li><li class="chapter-item expanded "><a href="lib/pep440.html"><strong aria-hidden="true">5.2.</strong> pep440</a></li><li class="chapter-item expanded "><a href="lib/pep508.html"><strong aria-hidden="true">5.3.</strong> pep508</a></li><li class="chapter-item expanded "><a href="lib/pep518.html"><strong aria-hidden="true">5.4.</strong> pep518</a></li><li class="chapter-item expanded "><a href="lib/pep599.html"><strong aria-hidden="true">5.5.</strong> pep599</a></li><li class="chapter-item expanded "><a href="lib/pep600.html"><strong aria-hidden="true">5.6.</strong> pep600</a></li><li class="chapter-item expanded "><a href="lib/pep621.html"><strong aria-hidden="true">5.7.</strong> pep621</a></li><li class="chapter-item expanded "><a href="lib/poetry.html"><strong aria-hidden="true">5.8.</strong> poetry</a></li><li class="chapter-item expanded "><a href="lib/pypa.html"><strong aria-hidden="true">5.9.</strong> pypa</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pyproject.nix</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/adisbladis/pyproject.nix" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="flakes"><a class="header" href="#flakes">Flakes</a></h3>
<p><a href="https://nix.dev/concepts/flakes">Nix Flakes</a> has many different opinionated ways to manage it's outputs.
This is the absolute a example of a Flake containing a pyproject.nix installation to show you the essence of how to install pyproject.nix.</p>
<pre><code class="language-nix">{
  inputs.pyproject.url = &quot;github:adisbladis/pyproject.nix&quot;;
  inputs.pyproject.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;

  outputs = { self, nixpkgs, pyproject }: let
    inherit (nixpkgs) lib;

    # Loads pyproject.toml into a high-level project representation
    # Do you notice how this is not tied to any `system` attribute or package sets?
    # That is because `project` refers to a pure data representation.
    project = pyproject.lib.project.loadPyproject {
      # Read &amp; unmarshal pyproject.toml
      pyproject = lib.importTOML ./pyproject.toml;
    };

    # This example is only using x86_64-linux
    pkgs = nixpkgs.legacyPackages.x86_64-linux;

    # We are using the default Python3 interpreter &amp; package set
    python = pkgs.python3;

  in {

    # Create a development shell containing dependencies from `pyproject.toml`
    devShells.x86_64-linux.default = let
      # Returns a function that can be passed to `python.withPackages`
      arg = pyproject.lib.renderers.withPackages { inherit python project; };

      # Returns a wrapped environment (virtualenv like) with all our packages
      pythonEnv = python.withPackages arg;

    in pkgs.mkShell {
      packages = [ pythonEnv ];
    };

    # Build our package using `buildPythonPackage
    packages.x86_64-linux.default = let
      # Returns an attribute set that can be passed to `buildPythonPackage`.
      attrs = pyproject.lib.renderers.buildPythonPackage { inherit python project; };
    in python.pkgs.buildPythonPackage attrs;
  };
}
</code></pre>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/doc/src/getting-started.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="hacking"><a class="header" href="#hacking">Hacking</a></h1>
<p>This document outlines hacking on <code>pyproject.nix</code> itself, and lays out it's project structure.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h2>
<p>To start hacking run <code>nix develop -c run</code> to run the project in watch mode.</p>
<p>This will start up two processes:</p>
<ul>
<li>A <a href="https://github.com/adisbladis/nix-unit">Nix-unit</a> test runner</li>
<li>A <a href="https://rust-lang.github.io/mdBook/">documentation server</a> available at http://localhost:3000</li>
</ul>
<h2 id="project-structure--testing"><a class="header" href="#project-structure--testing">Project structure &amp; testing</a></h2>
<p>All Nix code lives in <code>lib/</code>. Each file has an implementation and a test suite.
The attribute path to a an attribute <code>parseVersion</code> in <code>lib/pep440.nix</code> would be <code>lib.pep440.parseVersion</code>.</p>
<p>A function in <code>lib/test.nix</code> maps over the public interface of the library and the test suite to generate coverage tests, ensuring that every exported symbol has at least one test covering it.</p>
<p>Integration tests meaning tests that perform environment constructions &amp; builds lives in <code>test/</code> and are exposed through Flake checks.</p>
<p>The manual you are reading right now is built from the <code>doc/</code> directory.
To edit a specific page see the &quot;Edit this page on GitHub&quot; link in the footer for each respective page.</p>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<ul>
<li>
<p>Run the entire unit test suite
<code>$ nix-unit --flake .#libTests</code></p>
</li>
<li>
<p>Run unit tests for an individual function
<code>$ nix-unit --flake .#libTests.pep440.parseVersion</code></p>
</li>
<li>
<p>Run integration tests
<code>$ nix flake check</code></p>
</li>
</ul>
<h2 id="formatter"><a class="header" href="#formatter">Formatter</a></h2>
<p>Before submitting a PR format the code with <code>nix fmt</code> and ensure Flake checks pass with <code>nix flake check</code>.</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/doc/src/HACKING.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="how-does-package-name-mapping-from-python-to-nixpkgs-work"><a class="header" href="#how-does-package-name-mapping-from-python-to-nixpkgs-work">How does package name mapping from Python to Nixpkgs work?</a></h2>
<p>Package names are normalized according to the <a href="https://packaging.python.org/en/latest/specifications/name-normalization/#normalization">PyPA normalization specification</a>.
Nixpkgs also uses the same normalization <a href="https://github.com/NixOS/nixpkgs/issues/245383">but has some legacy package names</a> that do not follow normalization guidelines.</p>
<h2 id="how-do-you-treat-dynamic-attributes"><a class="header" href="#how-do-you-treat-dynamic-attributes">How do you treat <code>dynamic</code> attributes?</a></h2>
<p>Pyproject.nix makes no attempt at parsing dynamic fields as it does not have the required knowledge to infer these.</p>
<p>When using the <code>withPackages</code> renderer most fields that may be dynamic are not even relevant and won't cause issues.
At other times, like when using the <code>buildPythonPackage</code> renderer problems occur as there is no way for the renderer to create the version attribute.</p>
<pre><code class="language-nix">let
  project = pyproject.project.loadPyproject { pyproject = lib.importTOML ./pyproject.toml; };
  python = pkgs.python3;
  attrs = pyproject.renderers.buildPythonPackage { inherit python project; };
in python.pkgs.buildPythonPackage attrs
</code></pre>
<p>Will result in an error from <code>buildPythonpackage</code> because <code>version</code> is missing:</p>
<pre><code>error: attribute 'version' missing

at /nix/store/gna8i238i3nnz6cizcayyfyfdzn28la5-nixpkgs/pkgs/development/interpreters/python/mk-python-derivation.nix:31:28:

    30|
    31| { name ? &quot;${attrs.pname}-${attrs.version}&quot;
      |                            ^
    32|
</code></pre>
<p>In these cases you can manually add attributes to the attribute set returned by the renderer:</p>
<pre><code class="language-nix">let
  project = pyproject.project.loadPyproject { pyproject = lib.importTOML ./pyproject.toml; };
  python = pkgs.python3;
  attrs = pyproject.renderers.buildPythonPackage { inherit python project; };
in python.pkgs.buildPythonPackage (attrs // {
  version = &quot;1.0&quot;;  # Not dynamically inferred
})
</code></pre>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/doc/src/FAQ.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="reference-documentation"><a class="header" href="#reference-documentation">Reference documentation</a></h1>
<p>The reference documentation is split up into two main categories:</p>
<ul>
<li>User facing APIs</li>
</ul>
<p>Contains high-level representations and has notions of things like a <code>project</code> (a fully parsed <code>pyproject.toml</code>) and further operations done on the project level.</p>
<ul>
<li>Standards APIs</li>
</ul>
<p>Contains parsers, evaluators &amp; utility functions for dealing with Python packaging standards defined by the through the PEP process &amp; from PyPA.</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/doc/src/reference.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ pep518, pep621, poetry, ... }:</p>
<p>{
/* Load dependencies from a pyproject.toml.</p>
<pre><code> Type: loadPyproject :: AttrSet -&gt; AttrSet

 Example:
   # loadPyproject { pyproject = lib.importTOML }
   {
     dependencies = { }; # Parsed dependency structure in the schema of `lib.pep621.parseDependencies`
     build-systems = [ ];  # Returned by `lib.pep518.parseBuildSystems`
     pyproject = { }; # The unmarshaled contents of pyproject.toml
   }
</code></pre>
<p>*/
loadPyproject =
{
# The unmarshaled contents of pyproject.toml
pyproject
# Example: extrasAttrPaths = [ &quot;tool.pdm.dev-dependencies&quot; ];
, extrasAttrPaths ? [ ]
}: {
dependencies = pep621.parseDependencies { inherit pyproject extrasAttrPaths; };
build-systems = pep518.parseBuildSystems pyproject;
inherit pyproject;
};</p>
<p>/* Load dependencies from a Poetry pyproject.toml.</p>
<pre><code> Type: loadPoetryPyproject :: AttrSet -&gt; AttrSet

 Example:
   # loadPoetryPyproject { pyproject = lib.importTOML }
   {
     dependencies = { }; # Parsed dependency structure in the schema of `lib.pep621.parseDependencies`
     build-systems = [ ];  # Returned by `lib.pep518.parseBuildSystems`
     pyproject = { }; # The unmarshaled contents of pyproject.toml
   }
</code></pre>
<p>*/
loadPoetryPyproject =
{
# The unmarshaled contents of pyproject.toml
pyproject
}:
let
pyproject-pep621 = poetry.translatePoetryProject pyproject;
in
{
dependencies = poetry.parseDependencies pyproject;
build-systems = pep518.parseBuildSystems pyproject;
pyproject = pyproject-pep621;
pyproject-poetry = pyproject;
};</p>
<p>}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/project.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib
, pep508
, pep621
, ...
}:
let
inherit (builtins) attrValues length attrNames head foldl';
inherit (lib) optionalAttrs flatten mapAttrs' filterAttrs;</p>
<h1 id="group-licenses-by-their-spdx-ids-for-easy-lookup"><a class="header" href="#group-licenses-by-their-spdx-ids-for-easy-lookup">Group licenses by their SPDX IDs for easy lookup</a></h1>
<p>licensesBySpdxId = mapAttrs'
(<em>: license: {
name = license.spdxId;
value = license;
})
(filterAttrs (</em>: license: license ? spdxId) lib.licenses);</p>
<p>in
{
/*
Renders a project as an argument that can be passed to withPackages</p>
<pre><code>Evaluates PEP-508 environment markers to select correct dependencies for the platform but does not validate version constraints.
For validation see `lib.validators`.

Type: withPackages :: AttrSet -&gt; lambda

Example:
  # withPackages (lib.project.loadPyproject { ... })
    «lambda @ «string»:1:1»
*/
</code></pre>
<p>withPackages =
{
# Project metadata as returned by <code>lib.project.loadPyproject</code>
project
, # Python derivation
python
, # Python extras (optionals) to enable
extras ? [ ]
,
}:
let
filteredDeps = pep621.filterDependencies {
inherit (project) dependencies;
environ = pep508.mkEnviron python;
inherit extras;
};
namedDeps = pep621.getDependenciesNamesNormalized filteredDeps;
flatDeps = namedDeps.dependencies ++ flatten (attrValues namedDeps.extras) ++ namedDeps.build-systems;
in
ps: map (dep: ps.${dep}) flatDeps;</p>
<p>/*
Renders a project as an argument that can be passed to buildPythonPackage/buildPythonApplication.</p>
<pre><code>Evaluates PEP-508 environment markers to select correct dependencies for the platform but does not validate version constraints.
For validation see `lib.validators`.

Type: buildPythonPackage :: AttrSet -&gt; AttrSet

Example:
  # buildPythonPackage { project = lib.project.loadPyproject ...; python = pkgs.python3;  }
    { pname = &quot;blinker&quot;; version = &quot;1.3.3.7&quot;; propagatedBuildInputs = [ ]; }
*/
</code></pre>
<p>buildPythonPackage =
{
# Project metadata as returned by <code>lib.project.loadPyproject</code>
project
, # Python derivation
python
, # Python extras (optionals) to enable
extras ? [ ]
, # Map a Python extras group name to a Nix attribute set.
# This is intended to be used with optionals such as test dependencies that you might
# want to add to checkInputs instead of propagatedBuildInputs
extrasAttrMappings ? { }
, # Which package format to pass to buildPythonPackage
# If the format is &quot;wheel&quot; PEP-518 build-systems are excluded from the build.
format ? &quot;pyproject&quot;
}:
let
filteredDeps = pep621.filterDependencies {
inherit (project) dependencies;
environ = pep508.mkEnviron python;
inherit extras;
};</p>
<pre><code>  namedDeps = pep621.getDependenciesNamesNormalized filteredDeps;

  inherit (project) pyproject;

  meta =
    let
      project' = project.pyproject.project;
      urls = project'.urls or { };
    in
    # Optional changelog
    optionalAttrs (urls ? changelog)
      {
        inherit (urls) changelog;
      } //
    # Optional description
    optionalAttrs (project' ? description) {
      inherit (project') description;
    } //
    # Optional license
    optionalAttrs (project'.license ? text) (
      assert !(project'.license ? file); {
        # From PEP-621:
        # &quot;The text key has a string value which is the license of the project whose meaning is that of the License field from the core metadata.
        # These keys are mutually exclusive, so a tool MUST raise an error if the metadata specifies both keys.&quot;
        # Hence the assert above.
        license = licensesBySpdxId.${project'.license.text};
      }
    ) //
    # Only set mainProgram if we only have one script, otherwise it's ambigious which one is main
    (
      let
        scriptNames = attrNames project'.scripts;
      in
      optionalAttrs (project' ? scripts &amp;&amp; length scriptNames == 1) {
        mainProgram = head scriptNames;
      }
    );

in
foldl'
  (attrs: group:
  let
    attr = extrasAttrMappings.${group} or &quot;propagatedBuildInputs&quot;;
  in
  attrs // {
    ${attr} = attrs.${attr} or [ ] ++ map (dep: python.pkgs.${dep}) namedDeps.extras.${group};
  })
  ({
    propagatedBuildInputs = map (dep: python.pkgs.${dep}) namedDeps.dependencies;
    inherit format meta;
  } // optionalAttrs (format != &quot;wheel&quot;) {
    nativeBuildInputs = map (dep: python.pkgs.${dep}) namedDeps.build-systems;
  } // optionalAttrs (pyproject.project ? name) {
    pname = pyproject.project.name;
  }
  // optionalAttrs (pyproject.project ? version) {
    inherit (pyproject.project) version;
  })
  (attrNames namedDeps.extras);
</code></pre>
<p>}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/renderers.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib
, pep440
, pep508
, pep621
, pypa
, ...
}:
let
inherit (builtins) attrValues foldl' filter;
inherit (lib) flatten;</p>
<p>in
{
/*
Validates the Python package set held by Python (<code>python.pkgs</code>) against the parsed project.</p>
<pre><code>Returns an attribute set where the name is the Python package derivation `pname` and the value is a list of the mismatching conditions.

Type: validateVersionConstraints :: AttrSet -&gt; AttrSet

Example:
  # validateVersionConstraints (lib.project.loadPyproject { ... })
  {
    resolvelib = {
      # conditions as returned by `lib.pep440.parseVersionCond`
      conditions = [ { op = &quot;&gt;=&quot;; version = { dev = null; epoch = 0; local = null; post = null; pre = null; release = [ 1 0 1 ]; }; } ];
      # Version from Python package set
      version = &quot;0.5.5&quot;;
    };
    unearth = {
      conditions = [ { op = &quot;&gt;=&quot;; version = { dev = null; epoch = 0; local = null; post = null; pre = null; release = [ 0 10 0 ]; }; } ];
      version = &quot;0.9.1&quot;;
    };
  }
*/
</code></pre>
<p>validateVersionConstraints =
{
# Project metadata as returned by <code>lib.project.loadPyproject</code>
project
, # Python derivation
python
, # Python extras (optionals) to enable
extras ? [ ]
,
}:
let
filteredDeps = pep621.filterDependencies {
inherit (project) dependencies;
environ = pep508.mkEnviron python;
inherit extras;
};
flatDeps = filteredDeps.dependencies ++ flatten (attrValues filteredDeps.extras) ++ filteredDeps.build-systems;</p>
<pre><code>in
foldl'
  (acc: dep:
  let
    pname = pypa.normalizePackageName dep.name;
    pversion = python.pkgs.${pname}.version;
    version = pep440.parseVersion python.pkgs.${pname}.version;
    incompatible = filter (cond: ! pep440.comparators.${cond.op} version cond.version) dep.conditions;
  in
  if incompatible == [ ] then acc else acc // {
    ${pname} = {
      version = pversion;
      conditions = incompatible;
    };
  })
  { }
  flatDeps;
</code></pre>
<p>}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/validators.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="reference-documentation-1"><a class="header" href="#reference-documentation-1">Reference documentation</a></h1>
<p>The reference documentation is split up into two main categories:</p>
<ul>
<li>User facing APIs</li>
</ul>
<p>Contains high-level representations and has notions of things like a <code>project</code> (a fully parsed <code>pyproject.toml</code>) and further operations done on the project level.</p>
<ul>
<li>Standards APIs</li>
</ul>
<p>Contains parsers, evaluators &amp; utility functions for dealing with Python packaging standards defined by the through the PEP process &amp; from PyPA.</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/doc/src/reference.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>_:</p>
<p>let
inherit (builtins) match elemAt split filter isString;
matchFileName = match &quot;(<sup class="footnote-reference"><a href="#-">1</a></sup>+)-(<sup class="footnote-reference"><a href="#-">1</a></sup>+)(-([[:digit:]]<sup class="footnote-reference"><a href="#-">1</a></sup>*))?-(<sup class="footnote-reference"><a href="#-">1</a></sup>+)-(<sup class="footnote-reference"><a href="#-">1</a></sup>+)-(.+).whl&quot;;</p>
<p>in
{
/* Check whether string is a wheel file or not.</p>
<pre><code> Type: isWheelFileName :: string -&gt; bool

 Example:
 # isWheelFileName &quot;cryptography-41.0.1-cp37-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl&quot;
 true
</code></pre>
<p>*/
isWheelFileName = name: matchFileName name != null;</p>
<p>/* Parse PEP-427 wheel file names.</p>
<pre><code> Type: parseFileName :: string -&gt; AttrSet

 Example:
 # parseFileName &quot;cryptography-41.0.1-cp37-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl&quot;
 {
  abiTag = &quot;abi3&quot;;
  buildTag = null;
  distribution = &quot;cryptography&quot;;
  languageTag = &quot;cp37&quot;;
  platformTags = [ &quot;manylinux_2_17_aarch64&quot; &quot;manylinux2014_aarch64&quot; ];
  version = &quot;41.0.1&quot;;
}
</code></pre>
<p>*/
parseFileName =
# The wheel filename is <code>{distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl</code>.
name:
let
m = matchFileName name;
mAt = elemAt m;
in
assert m != null; {
distribution = mAt 0;
version = mAt 1;
buildTag = mAt 3;
languageTag = mAt 4;
abiTag = mAt 5;
platformTags = filter isString (split &quot;\.&quot; (mAt 6));
};
}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep427.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib, ... }:
let
inherit (builtins) split filter match length elemAt head tail foldl' fromJSON typeOf;
inherit (lib) fix isString toInt toLower sublist;</p>
<p>filterNull = filter (x: x != null);
filterEmpty = filter (x: length x &gt; 0);
filterEmptyStr = filter (s: s != &quot;&quot;);</p>
<h1 id="a-version-of-libtoint-that-supports-leading-zeroes"><a class="header" href="#a-version-of-libtoint-that-supports-leading-zeroes">A version of lib.toInt that supports leading zeroes</a></h1>
<p>toIntRelease = s:
let
n = fromJSON (head (match &quot;0?([[:digit:]]+)&quot; s));
in
assert typeOf n == &quot;int&quot;; n;</p>
<h1 id="return-a-list-elem-at-index-with-a-default-value-if-it-doesnt-exist"><a class="header" href="#return-a-list-elem-at-index-with-a-default-value-if-it-doesnt-exist">Return a list elem at index with a default value if it doesn't exist</a></h1>
<p>optionalElem = list: idx: default: if length list &gt;= idx + 1 then elemAt list idx else default;</p>
<h1 id="we-consider-some-words-to-be-alternate-spellings-of-other-words-and"><a class="header" href="#we-consider-some-words-to-be-alternate-spellings-of-other-words-and">We consider some words to be alternate spellings of other words and</a></h1>
<h1 id="in-those-cases-we-want-to-normalize-the-spellings-to-our-preferred"><a class="header" href="#in-those-cases-we-want-to-normalize-the-spellings-to-our-preferred">in those cases we want to normalize the spellings to our preferred</a></h1>
<h1 id="spelling"><a class="header" href="#spelling">spelling.</a></h1>
<p>normalizedReleaseTypes = {
alpha = &quot;a&quot;;
beta = &quot;b&quot;;
c = &quot;rc&quot;;
pre = &quot;rc&quot;;
preview = &quot;rc&quot;;
rev = &quot;post&quot;;
r = &quot;post&quot;;
&quot;-&quot; = &quot;post&quot;;
};</p>
<h1 id="parse-a-release-prepostwhatever-attrset-from-split-tokens"><a class="header" href="#parse-a-release-prepostwhatever-attrset-from-split-tokens">Parse a release (pre/post/whatever) attrset from split tokens</a></h1>
<p>parseReleaseSuffix = patterns: tokens:
let
matches = map
(x:
let
type = toLower (elemAt x 0);
value = elemAt x 1;
in
{
type = normalizedReleaseTypes.${type} or type;
value = if value != &quot;&quot; then toInt value else 0;
})
(filterNull (map (match &quot;[0-9]<em>(${patterns})([0-9]</em>)&quot;) tokens));
in
assert length matches &lt;= 1; optionalElem matches 0 null;</p>
<p>parsePre = parseReleaseSuffix &quot;a|b|c|rc|alpha|beta|pre|preview&quot;;
parsePost = parseReleaseSuffix &quot;post|rev|r|-&quot;;
parseDev = parseReleaseSuffix &quot;dev&quot;;
parseLocal = parseReleaseSuffix &quot;\+&quot;;</p>
<h1 id="compare-the-release-fields-from-the-parsed-version"><a class="header" href="#compare-the-release-fields-from-the-parsed-version">Compare the release fields from the parsed version</a></h1>
<p>compareRelease = ra: rb:
let
x = head ra;
y = head rb;
in
if length ra == 0 || length rb == 0 then 0 else
(
if x == &quot;<em>&quot; || y == &quot;</em>&quot; then 0 # Wildcards are always considered equal
else
(
if x &gt; y then 1
else if x &lt; y then -1
else compareRelease (tail ra) (tail rb)
)
);</p>
<h1 id="normalized-modifier-to-its-priority-in-case-we-are-comparing-an-alpha-to-a-beta-or-similar"><a class="header" href="#normalized-modifier-to-its-priority-in-case-we-are-comparing-an-alpha-to-a-beta-or-similar">Normalized modifier to it's priority (in case we are comparing an alpha to a beta or similar)</a></h1>
<p>modifierPriority = {
dev = -1;
a = 0;
b = 1;
rc = 2;
post = 3;
};</p>
<h1 id="compare-devprepostlocal-release-modifiers"><a class="header" href="#compare-devprepostlocal-release-modifiers">Compare dev/pre/post/local release modifiers</a></h1>
<p>compareVersionModifier = x: y: assert x != null &amp;&amp; y != null; let
prioX = modifierPriority.${x.type};
prioY = modifierPriority.${y.type};
in
if prioX == prioY then
(
if x.value == y.value then 0
else if x.value &gt; y.value then 1
else -1
)
else if prioX &gt; prioY then 1
else 0;</p>
<p>in
fix (self: {</p>
<p>/* Parse a version according to PEP-440.</p>
<pre><code> Type: parseVersion :: string -&gt; AttrSet

 Example:
   # parseVersion &quot;3.0.0rc1&quot;
   {
     dev = null;
     epoch = 0;
     local = null;
     post = null;
     pre = {
       type = &quot;rc&quot;;
       value = 1;
     };
     release = [ 3 0 0 ];
   }
</code></pre>
<p><em>/
parseVersion = version:
let
tokens = filter isString (split &quot;\.&quot; version);
in
{
# Return epoch defaulting to 0
epoch = toInt (optionalElem (map head (filterNull (map (match &quot;[0-9]+!([0-9]+)&quot;) tokens))) 0 &quot;0&quot;);
release = map (t: (x: if x == &quot;</em>&quot; then x else toIntRelease x) (head t)) (filterEmpty (map (t: filterEmptyStr (match &quot;([\<em>0-9]</em>).*&quot; t)) tokens));
pre = parsePre tokens;
post = parsePost tokens;
dev = parseDev tokens;
local = parseLocal tokens;
};</p>
<p>/* Parse a version conditional.</p>
<pre><code> Type: parseVersionCond :: string -&gt; AttrSet

 Example:
   # parseVersionCond &quot;&gt;=3.0.0rc1&quot;
   {
     op = &quot;&gt;=&quot;;
     version = {
       dev = null;
       epoch = 0;
       local = null;
       post = null;
       pre = {
         type = &quot;rc&quot;;
         value = 1;
       };
       release = [ 3 0 0 ];
     };
   }
</code></pre>
<p>*/
parseVersionCond = cond: (
let
m = match &quot;([=&gt;&lt;!~^]+)(.+)&quot; cond;
mAt = elemAt m;
in
{
op = mAt 0;
version = self.parseVersion (mAt 1);
}
);</p>
<p>/* Compare two versions as parsed by <code>parseVersion</code> according to PEP-440.</p>
<pre><code> Returns:
   - -1 for less than
   - 0 for equality
   - 1 for greater than

 Type: compareVersions :: AttrSet -&gt; AttrSet -&gt; int

 Example:
   # compareVersions (parseVersion &quot;3.0.0&quot;) (parseVersion &quot;3.0.0&quot;)
   0
</code></pre>
<p>*/
compareVersions = a: b: foldl' (acc: comp: if acc != 0 then acc else comp) 0 [
# mixing dev/pre/post like:
# 1.0b2.post345.dev456
# 1.0b2.post345
# is valid and we need to consider them all.</p>
<pre><code># Compare release field
(compareRelease a.release b.release)

# Compare pre release
(
  if a.pre != null &amp;&amp; b.pre != null then compareVersionModifier a.pre b.pre
  else if a.pre != null then -1
  else if b.pre != null then 1
  else 0
)

# Compare dev release
(
  if a.dev != null &amp;&amp; b.dev != null then compareVersionModifier a.dev b.dev
  else if a.dev != null then -1
  else if b.dev != null then 1
  else 0
)

# Compare post release
(
  if a.post != null &amp;&amp; b.post != null then compareVersionModifier a.post b.post
  else if a.post != null then 1
  else if b.post != null then -1
  else 0
)

# Compare epoch
(
  if a.epoch == b.epoch then 0
  else if a.epoch &gt; b.epoch then 1
  else -1
)

# Compare local
(
  if a.local != null &amp;&amp; b.local != null then compareVersionModifier a.local b.local
  else if b.local != null then -1
  else 0
)
</code></pre>
<p>];</p>
<p>/* Map comparison operators as strings to a comparator function.</p>
<pre><code> Attributes:
   - [Compatible release clause](https://peps.python.org/pep-0440/#compatible-release): `~=`
   - [Version matching clause](https://peps.python.org/pep-0440/#version-matching): `==`
   - [Version exclusion clause](https://peps.python.org/pep-0440/#version-exclusion): `!=`
   - [Inclusive ordered comparison clause](https://peps.python.org/pep-0440/#inclusive-ordered-comparison): `&lt;=`, `&gt;=`
   - [Exclusive ordered comparison clause](https://peps.python.org/pep-0440/#exclusive-ordered-comparison): `&lt;`, `&gt;`
   - [Arbitrary equality clause](https://peps.python.org/pep-0440/#arbitrary-equality): `===`

 Type: operators.${operator} :: AttrSet -&gt; AttrSet -&gt; bool

 Example:
   # comparators.&quot;==&quot; (parseVersion &quot;3.0.0&quot;) (parseVersion &quot;3.0.0&quot;)
   true
</code></pre>
<p>*/
comparators = {
&quot;~=&quot; = a: b: (
# Local version identifiers are NOT permitted in this version specifier.
assert a.local == null &amp;&amp; b.local == null;
self.comparators.&quot;&gt;=&quot; a b &amp;&amp; self.comparators.&quot;==&quot; a (b // {
release = sublist 0 ((length b.release) - 1) b.release;
# If a pre-release, post-release or developmental release is named in a compatible release clause as V.N.suffix, then the suffix is ignored when determining the required prefix match.
pre = null;
post = null;
dev = null;
})
);
&quot;==&quot; = a: b: self.compareVersions a b == 0;
&quot;!=&quot; = a: b: self.compareVersions a b != 0;
&quot;&lt;=&quot; = a: b: self.compareVersions a b &lt;= 0;
&quot;&gt;=&quot; = a: b: self.compareVersions a b &gt;= 0;
&quot;&lt;&quot; = a: b: self.compareVersions a b &lt; 0;
&quot;&gt;&quot; = a: b: self.compareVersions a b &gt; 0;
&quot;===&quot; = throw &quot;Arbitrary equality clause not supported&quot;;
};</p>
<p>})</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep440.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib, pep440, pep599, ... }:</p>
<p>let
inherit (builtins) match elemAt split foldl' substring stringLength typeOf fromJSON isString head mapAttrs elem;
inherit (lib) stringToCharacters fix;
inherit (import ./util.nix { inherit lib; }) splitComma;</p>
<p>re = {
operators = &quot;([=&gt;&lt;!~^]+)&quot;;
version = &quot;([0-9.*x]+)&quot;;
};</p>
<h1 id="assign-numerical-priority-values-to-logical-conditions-so-we-can-do-proper-precedence-ordering"><a class="header" href="#assign-numerical-priority-values-to-logical-conditions-so-we-can-do-proper-precedence-ordering">Assign numerical priority values to logical conditions so we can do proper precedence ordering</a></h1>
<p>condPrio = {
and = 5;
or = 10;
not = 1;
&quot;&quot; = -1;
};
condGt = l: r: if l == &quot;&quot; then false else condPrio.${l} &gt;= condPrio.${r};</p>
<h1 id="parse-a-value-into-an-attrset-of" class="..;"><a class="header" href="#parse-a-value-into-an-attrset-of">Parse a value into an attrset of</a></h1>
<h1 id="will-parse-any-field-name-suffixed-with-version-as-a-pep-440-version-otherwise"><a class="header" href="#will-parse-any-field-name-suffixed-with-version-as-a-pep-440-version-otherwise">Will parse any field name suffixed with &quot;version&quot; as a PEP-440 version, otherwise</a></h1>
<h1 id="the-value-is-passed-through-and-the-type-is-inferred-with-builtinstypeof"><a class="header" href="#the-value-is-passed-through-and-the-type-is-inferred-with-builtinstypeof">the value is passed through and the type is inferred with builtins.typeOf</a></h1>
<p>parseValueVersionDynamic = name: value: (
if match &quot;^.+version&quot; name != null &amp;&amp; isString value then {
type = &quot;version&quot;;
value = pep440.parseVersion value;
} else {
type = typeOf value;
inherit value;
}
);</p>
<h1 id="strip-leadingtrailing-whitespace-from-string"><a class="header" href="#strip-leadingtrailing-whitespace-from-string">Strip leading/trailing whitespace from string</a></h1>
<p>stripStr = s: let t = match &quot;[\t ]<em>(.</em><sup class="footnote-reference"><a href="#\t ">1</a></sup>)[\t ]*&quot; s; in if t == null then &quot;&quot; else head t;</p>
<h1 id="remove-groupings---from-expression"><a class="header" href="#remove-groupings---from-expression">Remove groupings ( ) from expression</a></h1>
<p>unparen = expr':
let
expr = stripStr expr';
m = match &quot;\((.+)\)&quot; expr;
in
if m != null then elemAt m 0 else expr;</p>
<p>isMarkerVariable =
let
markerFields = [
&quot;implementation_name&quot;
&quot;implementation_version&quot;
&quot;os_name&quot;
&quot;platform_machine&quot;
&quot;platform_python_implementation&quot;
&quot;platform_release&quot;
&quot;platform_system&quot;
&quot;platform_version&quot;
&quot;python_full_version&quot;
&quot;python_version&quot;
&quot;sys_platform&quot;
&quot;extra&quot;
];
in
s: elem s markerFields;</p>
<p>unpackValue = value:
let
# If the value is a single ticked string we can't pass it plainly to toJSON.
# Normalise to a double quoted.
singleTicked = match &quot;^'(.+)'$&quot; value; # TODO: Account for escaped ' in input (unescape)
in
if isMarkerVariable value then value
else fromJSON (if singleTicked != null then &quot;&quot;&quot; + head singleTicked + &quot;&quot;&quot; else value);</p>
<p>compareOps = pep440.comparators // {
&quot;==&quot; = x: y: x == y; # Simple equality
};</p>
<p>boolOps = {
&quot;and&quot; = x: y: x &amp;&amp; y;
&quot;or&quot; = x: y: x || y;
};</p>
<p>isPrimitiveType =
let
primitives = [
&quot;int&quot;
&quot;float&quot;
&quot;string&quot;
&quot;bool&quot;
];
in
type: elem type primitives;</p>
<p>in
fix (self:
{</p>
<p>/* Parse PEP 508 markers into an AST.</p>
<pre><code> Type: parseMarkers :: string -&gt; AttrSet

 Example:
   # parseMarkers &quot;(os_name=='a' or os_name=='b') and os_name=='c'&quot;
   {
     lhs = {
       lhs = {
         lhs = {
           type = &quot;variable&quot;;
           value = &quot;os_name&quot;;
         };
         op = &quot;==&quot;;
         rhs = {
           type = &quot;string&quot;;
           value = &quot;a&quot;;
         };
         type = &quot;compare&quot;;
       };
       op = &quot;or&quot;;
       rhs = {
         lhs = {
           type = &quot;variable&quot;;
           value = &quot;os_name&quot;;
         };
         op = &quot;==&quot;;
         rhs = {
           type = &quot;string&quot;;
           value = &quot;b&quot;;
         };
         type = &quot;compare&quot;;
       };
       type = &quot;boolOp&quot;;
     };
     op = &quot;and&quot;;
     rhs = {
       lhs = {
         type = &quot;variable&quot;;
         value = &quot;os_name&quot;;
       };
       op = &quot;==&quot;;
       rhs = {
         type = &quot;string&quot;;
         value = &quot;c&quot;;
       };
       type = &quot;compare&quot;;
     };
     type = &quot;boolOp&quot;;
   }
</code></pre>
<p>*/
parseMarkers = input:
let
# Find the positions of lhs/op/rhs in the input string
pos = foldl'
(acc: c:
let
# # Look ahead to find the operator (either &quot;and&quot;, &quot;not&quot; or &quot;or&quot;).
cond =
if self.openP &gt; 0 || acc.inString then &quot;&quot;
else if substring acc.pos 5 input == &quot; and &quot; then &quot;and&quot;
else if substring acc.pos 4 input == &quot; or &quot; then &quot;or&quot;
else if substring acc.pos 5 input == &quot; not &quot; then &quot;not&quot;
else &quot;&quot;;</p>
<pre><code>        # When we've reached the operator we know the start/end positions of lhs/op/rhs
        rhsOffset =
          if cond != &quot;&quot; &amp;&amp; condGt cond acc.cond then
            (
              if (cond == &quot;and&quot; || cond == &quot;not&quot;) then 5
              else if (cond == &quot;or&quot;) then 4
              else throw &quot;Unknown cond: ${cond}&quot;
            ) else -1;

        self = {
          # If we are inside a string don't track the opening and closing of parens
          openP = if acc.inString then acc.openP else
          (
            if c == &quot;(&quot; then acc.openP + 1
            else if c == &quot;)&quot; then acc.openP - 1
            else acc.openP
          );

          # Check opening and closing of strings
          inString =
            if acc.inString &amp;&amp; c == &quot;'&quot; then true
            else if !acc.inString &amp;&amp; c == &quot;'&quot; then false
            else acc.inString;

          pos = acc.pos + 1;

          cond = if cond != &quot;&quot; then cond else acc.cond;

          lhs = if (rhsOffset != -1) then acc.pos else acc.lhs;
          rhs = if (rhsOffset != -1) then (acc.pos + rhsOffset) else acc.rhs;
        };

      in
      self)
    {
      openP = 0; # Number of open parens
      inString = false; # If the parser is inside a string
      pos = 0; # Parser position
      done = false;

      # Keep track of last logical condition to do precedence ordering
      cond = &quot;&quot;;

      # Stop positions for each value
      lhs = -1;
      rhs = -1;

    }
    (stringToCharacters input);

in
if pos.lhs == -1 then
  (
    let
      m = split re.operators (unparen input);
      mAt = elemAt m;
      lhs = stripStr (mAt 0);
    in
    {
      type = &quot;compare&quot;;
      lhs =
        if isMarkerVariable lhs then {
          type = &quot;variable&quot;;
          value = lhs;
        } else unpackValue lhs;
      op = elemAt (mAt 1) 0;
      rhs = parseValueVersionDynamic lhs (unpackValue (stripStr (mAt 2)));
    }
  ) else {
  type = &quot;boolOp&quot;;
  lhs = self.parseMarkers (unparen (substring 0 pos.lhs input));
  op = substring (pos.lhs + 1) (pos.rhs - pos.lhs - 2) input;
  rhs = self.parseMarkers (unparen (substring pos.rhs (stringLength input) input));
};
</code></pre>
<p>/* Parse a PEP-508 dependency string.</p>
<pre><code> Type: parseString :: string -&gt; AttrSet

 Example:
   # parseString &quot;cachecontrol[filecache]&gt;=0.13.0&quot;
   {
     conditions = [
       {
         op = &quot;&gt;=&quot;;
         version = {
           dev = null;
           epoch = 0;
           local = null;
           post = null;
           pre = null;
           release = [ 0 13 0 ];
         };
       }
     ];
     markers = null;
     name = &quot;cachecontrol&quot;;
     extras = [ &quot;filecache&quot; ];
     url = null;
   }
</code></pre>
<p>*/
parseString = input:
let
# Split the input into it's distinct parts: The package segment, URL and environment markers
tokens =
let
# Input has both @ and ; separators (both URL and markers)
# &quot;name [fred,bar] @ http://foo.com ; python_version=='2.7'&quot;
m1 = match &quot;^(.+)@(.+);(.+)$&quot; input;</p>
<pre><code>      # Input has ; separator (markers)
      # &quot;name [fred,bar] ; python_version=='2.7'&quot;
      m2 = match &quot;^(.+);(.+)$&quot; input;

      # Input has @ separator (URL)
      # &quot;name [fred,bar] @ http://foo.com&quot;
      m3 = match &quot;^(.+)@(.+)$&quot; input;

    in
    if m1 != null then {
      packageSegment = elemAt m1 0;
      url = stripStr (elemAt m1 1);
      markerSegment = elemAt m1 2;
    }
    else if m2 != null then {
      packageSegment = elemAt m2 0;
      url = null;
      markerSegment = elemAt m2 1;
    }
    else if m3 != null then {
      packageSegment = elemAt m3 0;
      url = stripStr (elemAt m3 1);
      markerSegment = null;
    }
    else {
      packageSegment = input;
      url = null;
      markerSegment = null;
    };

  # Extract metadata from the package segment
  package =
    let
      # Package has either both extras and version constraints or just extras
      # &quot;name [fred,bar]&gt;=3.10&quot;
      # &quot;name [fred,bar]&quot;
      m1 = match &quot;(.+)\\[(.*)](.*)&quot; tokens.packageSegment;

      # Package has either version constraints or is bare
      # &quot;name&gt;=3.2&quot;
      # &quot;name&quot;
      m2 = match &quot;([a-zA-Z0-9_\\.-]+)(.*)&quot; tokens.packageSegment;

      # The version conditions as a list of strings
      conditions = map pep440.parseVersionCond (splitComma (if m1 != null then elemAt m1 2 else elemAt m2 1));

      # Extras as a list of strings
      extras = if m1 != null then splitComma (elemAt m1 1) else [ ];

    in
    # Assert that either regex matched
    assert m1 != null || m2 != null; {
      name = stripStr (if m1 != null then elemAt m1 0 else elemAt m2 0);
      inherit extras conditions;
    };

in
{
  inherit (package) name conditions extras;
  inherit (tokens) url;
  markers = if tokens.markerSegment == null then null else self.parseMarkers tokens.markerSegment;
};
</code></pre>
<p>/* Create an attrset of platform variables.
As described in https://peps.python.org/pep-0508/#environment-markers.</p>
<pre><code> Type: mkEnviron :: derivation -&gt; AttrSet

 Example:
   # mkEnviron pkgs.python3
   {
     implementation_name = {
       type = &quot;string&quot;;
       value = &quot;cpython&quot;;
     };
     implementation_version = {
       type = &quot;version&quot;;
       value = {
         dev = null;
         epoch = 0;
         local = null;
         post = null;
         pre = null;
         release = [ 3 10 12 ];
       };
     };
     os_name = {
       type = &quot;string&quot;;
       value = &quot;posix&quot;;
     };
     platform_machine = {
       type = &quot;string&quot;;
       value = &quot;x86_64&quot;;
     };
     platform_python_implementation = {
       type = &quot;string&quot;;
       value = &quot;CPython&quot;;
     };
     # platform_release maps to platform.release() which returns
     # the running kernel version on Linux.
     # Because this field is not reproducible it's left empty.
     platform_release = {
       type = &quot;string&quot;;
       value = &quot;&quot;;
     };
     platform_system = {
       type = &quot;string&quot;;
       value = &quot;Linux&quot;;
     };
     # platform_version maps to platform.version() which also returns
     # the running kernel version on Linux.
     # Because this field is not reproducible it's left empty.
     platform_version = {
       type = &quot;version&quot;;
       value = {
         dev = null;
         epoch = 0;
         local = null;
         post = null;
         pre = null;
         release = [ ];
       };
     };
     python_full_version = {
       type = &quot;version&quot;;
       value = {
         dev = null;
         epoch = 0;
         local = null;
         post = null;
         pre = null;
         release = [ 3 10 12 ];
       };
     };
     python_version = {
       type = &quot;version&quot;;
       value = {
         dev = null;
         epoch = 0;
         local = null;
         post = null;
         pre = null;
         release = [ 3 10 ];
       };
     };
     sys_platform = {
       type = &quot;string&quot;;
       value = &quot;linux&quot;;
     };
   }
</code></pre>
<p>*/
mkEnviron = python:
let
inherit (python) stdenv;
targetMachine = pep599.manyLinuxTargetMachines.${stdenv.targetPlatform.parsed.cpu.name} or null;
in
mapAttrs
parseValueVersionDynamic
{
os_name =
if python.pname == &quot;jython&quot; then &quot;java&quot;
else &quot;posix&quot;;
sys_platform =
if stdenv.isLinux then &quot;linux&quot;
else if stdenv.isDarwin then &quot;darwin&quot;
else throw &quot;Unsupported platform&quot;;
platform_machine = targetMachine;
platform_python_implementation =
let
impl = python.passthru.implementation;
in
if impl == &quot;cpython&quot; then &quot;CPython&quot;
else if impl == &quot;pypy&quot; then &quot;PyPy&quot;
else throw &quot;Unsupported implementation ${impl}&quot;;
platform_release = &quot;&quot;; # Field not reproducible
platform_system =
if stdenv.isLinux then &quot;Linux&quot;
else if stdenv.isDarwin then &quot;Darwin&quot;
else throw &quot;Unsupported platform&quot;;
platform_version = &quot;&quot;; # Field not reproducible
python_version = python.passthru.pythonVersion;
python_full_version = python.version;
implementation_name = python.passthru.implementation;
implementation_version = python.version;
};</p>
<p>/* Evaluate an environment as returned by <code>mkEnviron</code> against markers as returend by <code>parseMarkers</code>.</p>
<pre><code> Type: evalMarkers :: AttrSet -&gt; AttrSet -&gt; bool

 Example:
   # evalMarkers (mkEnviron pkgs.python3) (parseMarkers &quot;python_version &lt; \&quot;3.11\&quot;&quot;)
   true
</code></pre>
<p>*/
evalMarkers = environ: value: (
let
x = self.evalMarkers environ value.lhs;
y = self.evalMarkers environ value.rhs;
in
if value.type == &quot;compare&quot; then
(
compareOps.${value.op} x y
)
else if value.type == &quot;boolOp&quot; then
(
boolOps.${value.op} x y
)
else if value.type == &quot;variable&quot; then (self.evalMarkers environ environ.${value.value})
else if value.type == &quot;version&quot; then value.value
else if isPrimitiveType value.type then value.value
else throw &quot;Unknown type '${value.type}'&quot;
);</p>
<p>})</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep508.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ pep508, ... }:</p>
<p>{
/* Parse PEP-518 <code>build-system.requires</code> from pyproject.toml.
Type: readPyproject :: AttrSet -&gt; list</p>
<pre><code> Example:
 # parseBuildSystems (lib.importTOML ./pyproject.toml)
   [ ]  # List of parsed PEP-508 strings as returned by `lib.pep508.parseString`.
</code></pre>
<p>*/
parseBuildSystems = pyproject: map pep508.parseString (pyproject.build-system.requires or [ ]);
}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep518.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>_:</p>
<p>{
/* Map Nixpkgs CPU values to target machines known to be supported for manylinux* wheels (a.k.a. <code>uname -m</code>),
in nixpkgs found under the attribute <code>stdenv.targetPlatform.parsed.cpu.name</code></p>
<pre><code> Example:
 # legacyAliases.powerpc64
 &quot;ppc64&quot;
</code></pre>
<p>*/
manyLinuxTargetMachines = {
x86_64 = &quot;x86_64&quot;;
i686 = &quot;i686&quot;;
aarch64 = &quot;aarch64&quot;;
armv7l = &quot;armv7l&quot;;
powerpc64 = &quot;ppc64&quot;;
powerpc64le = &quot;ppc64le&quot;;
s390x = &quot;s390x&quot;;
};
}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep599.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib, pep599, ... }:
let
inherit (builtins) match elemAt compareVersions splitVersion;
inherit (lib) fix;</p>
<p>in
fix (self: {
/* Map legacy (pre PEP-600) platform tags to PEP-600 compliant ones.</p>
<pre><code> https://peps.python.org/pep-0600/#legacy-manylinux-tags

 Type: legacyAliases.${tag} :: AttrSet -&gt; string

 Example:
 # legacyAliases.&quot;manylinux1_x86_64&quot; or &quot;manylinux1_x86_64&quot;
 &quot;manylinux_2_5_x86_64&quot;
</code></pre>
<p>*/
legacyAliases = {
manylinux1_x86_64 = &quot;manylinux_2_5_x86_64&quot;;
manylinux1_i686 = &quot;manylinux_2_5_i686&quot;;
manylinux2010_x86_64 = &quot;manylinux_2_12_x86_64&quot;;
manylinux2010_i686 = &quot;manylinux_2_12_i686&quot;;
manylinux2014_x86_64 = &quot;manylinux_2_17_x86_64&quot;;
manylinux2014_i686 = &quot;manylinux_2_17_i686&quot;;
manylinux2014_aarch64 = &quot;manylinux_2_17_aarch64&quot;;
manylinux2014_armv7l = &quot;manylinux_2_17_armv7l&quot;;
manylinux2014_ppc64 = &quot;manylinux_2_17_ppc64&quot;;
manylinux2014_ppc64le = &quot;manylinux_2_17_ppc64le&quot;;
manylinux2014_s390x = &quot;manylinux_2_17_s390x&quot;;
};</p>
<p>/* Check if a manylinux tag is compatible with a given stdenv.</p>
<pre><code> Type: manyLinuxTagCompatible :: AttrSet -&gt; string -&gt; bool

 Example:
 # manyLinuxTagCompatible pkgs.stdenv &quot;manylinux_2_5_x86_64&quot;
 true
</code></pre>
<p><em>/
manyLinuxTagCompatible = stdenv: tag:
let
tag' = self.legacyAliases.${tag} or tag;
m = match &quot;manylinux_([0-9]+)<em>([0-9]+)</em>(.</em>)&quot; tag';
mAt = elemAt m;
tagMajor = mAt 0;
tagMinor = mAt 1;
tagArch = mAt 2;
sysVersion' = elemAt (splitVersion stdenv.cc.libc.version);
sysMajor = sysVersion' 0;
sysMinor = sysVersion' 1;
in
if m == null then throw &quot;'${tag'}' is not a valid manylinux tag.&quot;
else if stdenv.cc.libc.pname != &quot;glibc&quot; then false
else if compareVersions &quot;${sysMajor}.${sysMinor}&quot; &quot;${tagMajor}.${tagMinor}&quot; &lt; 0 then false
else if pep599.manyLinuxTargetMachines.${tagArch} != stdenv.targetPlatform.parsed.cpu.name then false
else true;</p>
<p>})</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep600.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib, pep440, pep508, pep518, pypa, ... }:
let
inherit (builtins) mapAttrs foldl' split filter elem;
inherit (lib) isString filterAttrs fix;</p>
<p>splitAttrPath = path: filter isString (split &quot;\.&quot; path);
getAttrPath = path: lib.getAttrFromPath (splitAttrPath path);</p>
<p>in
fix (self: {
/* Parse dependencies from pyproject.toml.</p>
<pre><code> Type: parseDependencies :: AttrSet -&gt; AttrSet

 Example:
   # parseDependencies {
   #
   #   pyproject = (lib.importTOML ./pyproject.toml);
   #   # Don't just look at `project.optional-dependencies` for groups, also look at these:
   #   extrasAttrPaths = [ &quot;tool.pdm.dev-dependencies&quot; ];
   # }
   {
     dependencies = [ ];  # List of parsed PEP-508 strings (lib.pep508.parseString)
     extras = {
       dev = [ ];  # List of parsed PEP-508 strings (lib.pep508.parseString)
     };
     build-systems = [ ];  # PEP-518 build-systems (List of parsed PEP-508 strings)
   }
</code></pre>
<p>*/
parseDependencies = { pyproject, extrasAttrPaths ? [ ] }:
let
# Fold extras from all considered attributes into one set
extras' = foldl' (acc: attr: acc // getAttrPath attr pyproject) (pyproject.project.optional-dependencies or { }) extrasAttrPaths;
in
{
dependencies = map pep508.parseString (pyproject.project.dependencies or [ ]);
extras = mapAttrs (_: map pep508.parseString) extras';
build-systems = pep518.parseBuildSystems pyproject;
};</p>
<p>/* Parse project.python-requires from pyproject.toml</p>
<pre><code> Type: parseRequiresPython :: AttrSet -&gt; list

 Example:
   #  parseRequiresPython (lib.importTOML ./pyproject.toml)
   [ ]  # List of conditions as returned by `lib.pep440.parseVersionCond`
</code></pre>
<p>*/
parseRequiresPython = pyproject: map pep440.parseVersionCond (filter isString (split &quot;,&quot; (pyproject.project.requires-python or &quot;&quot;)));</p>
<p>/* Takes a dependency structure as returned by <code>lib.pep621.parseDependencies</code> and transforms it into
a structure with it's normalized names as normalized by <code>lib.pypa.normalizePackageName</code>.</p>
<pre><code> Type: getDependenciesNamesNormalized :: AttrSet -&gt; AttrSet

 Example:
   # getDependenciesNamesNormalized (pep621.parseDependencies { pyproject = (lib.importTOML ./pyproject.toml); })
   {
     dependencies = [ &quot;requests&quot; ];
     extras = {
       dev = [ &quot;pytest&quot; ];
     };
     build-systems = [ &quot;poetry-core&quot; ];
   }
</code></pre>
<p><em>/
getDependenciesNamesNormalized =
let
normalizeList = map (dep: pypa.normalizePackageName dep.name);
in
dependencies: {
dependencies = normalizeList dependencies.dependencies;
extras = mapAttrs (_: normalizeList) dependencies.extras;
build-systems = normalizeList dependencies.build-systems;
};
/</em> Filter dependencies not relevant for this environment.</p>
<pre><code> Type: filterDependenciesByEnviron :: AttrSet -&gt; AttrSet -&gt; AttrSet

 Example:
   # filterDependenciesByEnviron (lib.pep508.mkEnviron pkgs.python3) (lib.pep621.parseDependencies (lib.importTOML ./pyproject.toml))
   { }  # Structure omitted in docs
</code></pre>
<p>*/
filterDependenciesByEnviron =
let
filterList = environ: filter (dep: dep.markers == null || pep508.evalMarkers environ dep.markers);
in
# Environ as created by <code>lib.pep508.mkEnviron</code>.
environ:
# Dependencies as parsed by <code>lib.pep621.parseDependencies</code>.
dependencies:
{
dependencies = filterList environ dependencies.dependencies;
extras = mapAttrs (_: filterList environ) dependencies.extras;
build-systems = filterList environ dependencies.build-systems;
};</p>
<p>/* Filter dependencies by their extras groups.</p>
<pre><code> Type: filterDependenciesByExtras :: list[string] -&gt; AttrSet -&gt; AttrSet

 Example:
   # filterDependenciesByExtras [ &quot;dev&quot; ] (lib.pep621.parseDependencies (lib.importTOML ./pyproject.toml))
   { }  # Structure omitted in docs
</code></pre>
<p>*/
filterDependenciesByExtras =
# Extras groups as a list of strings.
extras:
# Dependencies as parsed by <code>lib.pep621.parseDependencies</code>.
dependencies:
dependencies // {
extras = filterAttrs (group: _: elem group extras) dependencies.extras;
};</p>
<p>/* Aggregate of <code>filterDependencies</code> &amp; <code>filterDependenciesByExtras</code></p>
<pre><code> Type: filterDependencies :: AttrSet -&gt; AttrSet

 Example:
   # filterDependencies {
   #   dependencies = lib.pep621.parseDependencies (lib.importTOML ./pyproject.toml);
   #   environ = lib.pep508.mkEnviron pkgs.python;
   #   extras = [ &quot;dev&quot; ];
   # }
   { }  # Structure omitted in docs
</code></pre>
<p>*/
filterDependencies =
{
# Dependencies as parsed by <code>lib.pep621.parseDependencies</code>
dependencies
, # Environ as created by <code>lib.pep508.mkEnviron</code>
environ
, # Extras as a list of strings
extras ? [ ]
,
}: self.filterDependenciesByEnviron environ (self.filterDependenciesByExtras extras dependencies);
})</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pep621.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib
, pep440
, pep508
, pep518
, ...
}:
let
inherit (builtins) match elemAt foldl' typeOf attrNames head tail mapAttrs;
inherit (lib) optionalAttrs flatten;
inherit (import ./util.nix { inherit lib; }) splitComma;</p>
<h1 id="translate-author-from-a-string-like-name--to-a-structured-set-as-defined-by-pep-621"><a class="header" href="#translate-author-from-a-string-like-name--to-a-structured-set-as-defined-by-pep-621">Translate author from a string like &quot;Name <email>&quot; to a structured set as defined by PEP-621.</a></h1>
<p>translateAuthor = a:
let
mAt = elemAt (match &quot;^(.+) &lt;(.+)&gt;$&quot; a);
in
{ name = mAt 0; email = mAt 1; };</p>
<h1 id="normalize-dependecy-from-poetry-dependencies-table-from-string--set---set"><a class="header" href="#normalize-dependecy-from-poetry-dependencies-table-from-string--set---set">Normalize dependecy from poetry dependencies table from (string || set) -&gt; set</a></h1>
<p>normalizeDep = name: dep: (
let
type = typeOf dep;
in
if type == &quot;string&quot; then {
inherit name;
version = dep;
}
else if type == &quot;set&quot; then dep // { inherit name; }
else throw &quot;Unexpected type: ${type}&quot;
);</p>
<h1 id="rewrite-the-right-hand-side-version-for-caret-comparisons-according-to-the-rules-laid-out-in"><a class="header" href="#rewrite-the-right-hand-side-version-for-caret-comparisons-according-to-the-rules-laid-out-in">Rewrite the right hand side version for caret comparisons according to the rules laid out in</a></h1>
<h1 id="httpspython-poetryorgdocsdependency-specificationcaret-requirements"><a class="header" href="#httpspython-poetryorgdocsdependency-specificationcaret-requirements">https://python-poetry.org/docs/dependency-specification/#caret-requirements</a></h1>
<p>rewriteCaretRhs = release:
let
state = foldl'
(state: v:
let
nonzero = state.nonzero || v != 0;
in
state // {
release = state.release ++ [
(
if nonzero &amp;&amp; !state.nonzero then (v + 1)
else if nonzero then 0
else v
)
];
inherit nonzero;
})
{
release = [ ];
nonzero = false;
}
release;
in
if !state.nonzero
then ([ (head state.release + 1) ] ++ tail state.release)
else state.release;</p>
<h1 id="poetry-dependency-tables-are-of-mixed-types"><a class="header" href="#poetry-dependency-tables-are-of-mixed-types">Poetry dependency tables are of mixed types:</a></h1>
<h1 id="toolpoetrydependencies"><a class="header" href="#toolpoetrydependencies">[tool.poetry.dependencies]</a></h1>
<h1 id="python--38"><a class="header" href="#python--38">python = &quot;^3.8&quot;</a></h1>
<h1 id="cachecontrol-"><a class="header" href="#cachecontrol-">cachecontrol =</a></h1>
<h1 id="foo--"><a class="header" href="#foo--">foo = [</a></h1>
<h1 id="version--19-python--3638"><a class="header" href="#version--19-python--3638">{version = &quot;&lt;=1.9&quot;, python = &quot;&gt;=3.6,&lt;3.8&quot;},</a></h1>
<h1 id="version--20-python--38"><a class="header" href="#version--20-python--38">{version = &quot;^2.0&quot;, python = &quot;&gt;=3.8&quot;}</a></h1>
<h1 id=""><a class="header" href="#">]</a></h1>
<h1 id="-1"><a class="header" href="#-1"></a></h1>
<h1 id="these-are-all-valid-normalize-the-input-to-a-list-of"><a class="header" href="#these-are-all-valid-normalize-the-input-to-a-list-of">These are all valid. Normalize the input to a list of:</a></h1>
<h1 id="-2"><a class="header" href="#-2">[</a></h1>
<h1 id="-3"><a class="header" href="#-3"></a></h1>
<h1 id="-4"><a class="header" href="#-4"></a></h1>
<h1 id="-name--foo-version--19--python--3638-"><a class="header" href="#-name--foo-version--19--python--3638-">{ name = &quot;foo&quot;; version = &quot;&lt;=1.9&quot;;  python = &quot;&gt;=3.6,&lt;3.8&quot;; }</a></h1>
<h1 id="-name--foo-version--20-python--38-"><a class="header" href="#-name--foo-version--20-python--38-">{ name = &quot;foo&quot;; version = &quot;^2.0&quot;; python = &quot;&gt;=3.8&quot;; }</a></h1>
<h1 id="-5"><a class="header" href="#-5">]</a></h1>
<p>normalizeDependendenciesToList = deps: foldl'
(acc: name: acc ++ (
let
dep = deps.${name};
in
if typeOf dep == &quot;list&quot; then map (normalizeDep name) dep
else [ (normalizeDep name dep) ]
)) [ ]
(attrNames deps);</p>
<h1 id="supports-additional-non-standard-operators--and--used-by-poetry"><a class="header" href="#supports-additional-non-standard-operators--and--used-by-poetry">Supports additional non-standard operators <code>^</code> and <code>~</code> used by Poetry.</a></h1>
<h1 id="other-operators-are-passed-through-to-pep440"><a class="header" href="#other-operators-are-passed-through-to-pep440">Other operators are passed through to pep440.</a></h1>
<h1 id="because-some-expressions-desugar-to-multiple-expressions-parseversioncond-returns-a-list"><a class="header" href="#because-some-expressions-desugar-to-multiple-expressions-parseversioncond-returns-a-list">Because some expressions desugar to multiple expressions parseVersionCond returns a list.</a></h1>
<p>parseVersionCond' = cond: (
let
m = match &quot;^([<del>[:digit:]^])(.+)$&quot; cond;
mAt = elemAt m;
c = mAt 0;
rest = mAt 1;
# Pad version before parsing as it's <em>much</em> easier to reason about
# once they're the same length
version = pep440.parseVersion (lib.versions.pad 3 rest);
in
if m == null then [ (pep440.parseVersionCond cond) ]
# Desugar ~ into &gt;= &amp;&amp; &lt;
else if c == &quot;</del>&quot; then [
{
cond = &quot;&gt;=&quot;;
inherit version;
}
{
cond = &quot;&lt;&quot;;
version = version // {
release = [ (head version.release + 1) ] ++ tail version.release;
};
}
]
# Desugar ^ into &gt;= &amp;&amp; &lt;
else if c == &quot;^&quot; then [
{
cond = &quot;&gt;=&quot;;
inherit version;
}
{
cond = &quot;&lt;&quot;;
version = version // {
release = rewriteCaretRhs version.release;
};
}
]
# Versions without operators are exact matches, add operator according to PEP-440
else [{
cond = &quot;==&quot;;
inherit version;
}]
);</p>
<h1 id="normalized-version-of-parseversioncond"><a class="header" href="#normalized-version-of-parseversioncond">Normalized version of parseVersionCond'</a></h1>
<p>parseVersionConds = s: flatten (map parseVersionCond' (splitComma s));</p>
<p>dummyMarker = {
type = &quot;bool&quot;;
value = true;
};</p>
<h1 id="analogous-to-pep508parsestring"><a class="header" href="#analogous-to-pep508parsestring">Analogous to pep508.parseString</a></h1>
<p>parseDependency = dep:
let
# Poetry has Python as a separate field in the structured dependency object.
# This is non-standard. Rewrite these expressions as a nested set of logical ANDs that
# looks like regular parsed markers as if they were standard PEP-508, just written in a bit of a funky
# nested way that no human would do.
markers = foldl'
(rhs: pyCond: {
type = &quot;boolOp&quot;;
op = &quot;and&quot;;
lhs = {
type = &quot;compare&quot;;
inherit (pyCond) op;
lhs = {
type = &quot;variable&quot;;
value = &quot;python_version&quot;;
};
rhs = {
type = &quot;version&quot;;
value = pyCond.version;
};
};
inherit rhs;
})
(
# Encode no markers as a marker that always evaluates to true to simplify fold logi above.
if dep ? markers then pep508.parseMarkers dep.markers else dummyMarker
)
(if dep ? python then parseVersionConds dep.python else [ ]);</p>
<pre><code>in
{
  inherit (dep) name;
  conditions = parseVersionConds dep.version;
  extras = dep.extras or [ ];
  url = dep.url or null;
  markers = if markers == dummyMarker then null else markers;
};
</code></pre>
<p>in
{
/*
Translate a Pyproject.toml from Poetry to PEP-621 project metadata.
This function transposes a PEP-621 project table on top of an existing Pyproject.toml populated with data from <code>tool.poetry</code>.
Notably does not translate dependencies/optional-dependencies.</p>
<pre><code>For parsing dependencies from Poetry see `lib.poetry.parseDependencies`.

Type: translatePoetryProject :: AttrSet -&gt; lambda

Example:
  # translatePoetryProject (lib.importTOML ./pyproject.toml)
  { }  # TOML contents, structure omitted. See PEP-621 for more information on data members.
*/
</code></pre>
<p>translatePoetryProject = pyproject: assert !(pyproject ? project); let
inherit (pyproject.tool) poetry;
in
pyproject // {
project = {
inherit (poetry) name version description;
authors = map translateAuthor poetry.authors;
urls = optionalAttrs (poetry ? homepage)
{
Homepage = poetry.homepage;
} // optionalAttrs (poetry ? repository) {
Repository = poetry.repository;
} // optionalAttrs (poetry ? documentation) {
Documentation = poetry.documentation;
};
} // optionalAttrs (poetry ? license) {
license.text = poetry.license;
} // optionalAttrs (poetry ? maintainers) {
maintainers = map translateAuthor poetry.maintainers;
} // optionalAttrs (poetry ? readme) {
inherit (poetry) readme;
} // optionalAttrs (poetry ? keywords) {
inherit (poetry) keywords;
} // optionalAttrs (poetry ? classifiers) {
inherit (poetry) classifiers;
};
};</p>
<p>/* Parse dependencies from pyproject.toml (Poetry edition).
This function is analogous to <code>lib.pep621.parseDependencies</code>.</p>
<pre><code> Type: parseDependencies :: AttrSet -&gt; AttrSet

 Example:
   # parseDependencies {
   #
   #   pyproject = (lib.importTOML ./pyproject.toml);
   # }
   {
     dependencies = [ ];  # List of parsed PEP-508 strings (lib.pep508.parseString)
     extras = {
       dev = [ ];  # List of parsed PEP-508 strings (lib.pep508.parseString)
     };
     build-systems = [ ];  # PEP-518 build-systems (List of parsed PEP-508 strings)
   }
</code></pre>
<p>*/</p>
<h1 id="analogous-to"><a class="header" href="#analogous-to"># Analogous to</a></h1>
<p>parseDependencies = pyproject: {
dependencies = map parseDependency (normalizeDependendenciesToList (pyproject.tool.poetry.dependencies or { }));
extras = mapAttrs (_: g: map parseDependency (normalizeDependendenciesToList g.dependencies)) pyproject.tool.poetry.group or { };
build-systems = pep518.parseBuildSystems pyproject;
};
}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/poetry.nix">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><p>{ lib, ... }:
let
inherit (builtins) concatStringsSep filter split;
inherit (lib) isString toLower;</p>
<p>in
{
/* Normalize package name as documented in https://packaging.python.org/en/latest/specifications/name-normalization/#normalization</p>
<pre><code> Type: normalizePackageName :: string -&gt; string

 Example:
   # readPyproject &quot;Friendly-Bard&quot;
   &quot;friendly-bard&quot;
</code></pre>
<p>*/
normalizePackageName =
let
concatDash = concatStringsSep &quot;-&quot;;
splitSep = split &quot;[-_.]+&quot;;
in
name: toLower (concatDash (filter isString (splitSep name)));
}</p>
<footer id="open-on-gh">Found an issue? <a href="https://github.com/adisbladis/pyproject.nix/edit/master/lib/pypa.nix">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
